## Marble Roulette (Matter.js) — 구현 의도 / 구조 설명

이 프로젝트는 **단순 “랜덤 추첨”** 이 아니라,  
**여러 개의 구슬이 동시에 떨어지는 레이스**에서 **특정 등수(지목 등수)로 도착한 이름을 추첨**하는 게임입니다.

핵심 목표는 3가지입니다.

1) **전원 반드시 골인(완주)** 하게 만들기  
2) **카메라가 자동으로 선두를 따라가서** 레이스가 “진행되는 느낌”을 주기  
3) **꼴찌가 화면 밖으로 사라질 때만** 미니뷰(Last)를 보여줘서 추적 가능하게 하기


---

## 1. “전원 골인 보장”을 왜 했나?

Matter.js 물리는 자연스러운 대신,
- 바닥/기울기/장애물/마찰 조합에 따라
- 공이 **구멍 주변에서 튕기거나 끼어서** “영원히 안 들어가는” 상황이 쉽게 발생합니다.

추첨 게임에서 이 현상은 치명적입니다.
- 누군가만 골인을 못 하면 **레이스 결과(등수)가 확정되지 않음**
- 사용자 입장에서는 “버그처럼” 느껴짐

그래서 이 프로젝트는 골인 구간에 **흡입(Suction) 로직**을 추가해서  
**일정 반경 안에 들어오면 골인 센터로 빨려들어가게** 설계했습니다.

### 적용 방식
- `SUCTION_RADIUS` : 흡입 시작 반경
- `SUCTION_FORCE` : 빨아들이는 힘
- `NEAR_RADIUS` : 거의 도착하면 물리 계산 없이 즉시 finish 처리  
- 골인 시에는 `animateSinkAndRemove()`로 시각적으로 “쏙 들어가는” 연출 후 제거

즉,
- 물리 엔진의 “확률적/불완전한 골인”을
- **게임 규칙(완주 보장)**으로 덮어서
- 추첨 결과가 항상 확정되도록 만들었습니다.


---

## 2. “지목 등수(Target Rank)” 추첨 구조

일반 추첨(랜덤 pick)과 달리,
여긴 **레이스 결과 = 추첨 결과**입니다.

- 입력된 이름들이 공으로 생성되고
- 떨어지면서 장애물/스프링/회전바에 의해 경로가 달라지고
- 골인한 순서가 `finishOrder`로 기록됩니다.

사용자는 `targetRank`(예: 3등)를 지정할 수 있고,
- 해당 등수로 들어온 이름이 “당첨”으로 기록됩니다.

이 방식의 장점
- “랜덤”이 아니라 **물리 기반 진행**이라 보는 재미가 있고
- 순서가 쌓이는 과정이 보여서 **신뢰감(납득감)**이 생깁니다.


---

## 3. 왜 “카메라(뷰 바운즈)”를 직접 제어했나?

Matter.js 렌더는 기본적으로 고정 화면이지만,
이 게임은 월드가 `WORLD_H` 만큼 길어서
그냥 두면 공이 아래로 내려가면서 화면 밖으로 사라집니다.

그래서 `Render.options.hasBounds = true` + `setCameraToY()`를 통해  
**렌더의 bounds를 움직여 카메라처럼 스크롤**합니다.

### 카메라 정책
- 레이스 시작 직후 `START_FOCUS_MS` 동안은 상단 고정
  - 시작 장면 안정적으로 보여주기
- 이후엔 선두(leader)의 y좌표를 따라가되
  - `CAMERA_SMOOTH`로 부드럽게 보간해서
  - 화면이 덜 흔들리고 보기 편하게 만듭니다.

즉,
단순 스크롤이 아니라  
**레이스 중계 카메라** 느낌을 목표로 했습니다.


---

## 4. “미니뷰(Last)”는 왜 조건부로만 보이나?

미니뷰는 항상 켜두면 화면이 복잡해지고,
사용자가 지금 보고 싶은 건 대부분 “선두 경쟁”입니다.

그래서 아래 정책을 적용했습니다.

- 메인 카메라는 **선두(leader)** 추적
- 꼴찌(last)가 메인 화면 밖으로 나가면
  - 그때만 miniWrap 표시
  - 미니 카메라는 꼴찌 공을 bounds로 추적

이렇게 하면
- 평소엔 깔끔한 화면 유지
- 필요할 때만 꼴찌 위치를 확인 가능

즉,
**정보를 “항상 보여주는 UI”가 아니라 “필요할 때만 나타나는 UI”**로 만든 겁니다.


---

## 5. 장애물/장치들은 왜 넣었나?

레이스 결과를 완전 단순 낙하로 두면
공들이 거의 비슷하게 떨어지고 결과가 단조롭습니다.

그래서 “물리적 분산”을 늘리는 장치를 배치했습니다.

- **Spinner(노란 회전 막대)** : 중앙에서 진행 흐름을 크게 흔듦
- **Moving Bars(빨간 좌우 이동 2개)** : 구간마다 레인(경로) 변화 유도
- **Star(파란 별 회전)** : 충돌 각도가 다양해져 랜덤성 증가
- **Wood Spinner(아래 나무 회전)** : 골인 직전 마지막 교란 구간
- **Mushroom Spring** : 특정 구간에서 강제 발사로 역전/분산 발생

결론적으로,
“단순 낙하” → “진짜 레이스처럼 변수가 생기는 낙하”로 바꾸는 장치들입니다.


---

## 6. Debug 옵션을 따로 둔 이유

물리 기반 게임은 “튜닝”이 핵심이라
아래 디버그 기능을 넣었습니다.

- `DEBUG_VIEW_GOAL`
  - 시작 전에도 골인 구역으로 카메라를 보내서
  - **골인/흡입/슬로프 형태를 반복 튜닝** 가능하게 함

- `DEBUG_SPAWN_ONE`
  - 공을 1개만 생성해서
  - 특정 구간 충돌/튕김/흡입만 빠르게 검증 가능

추가로 키보드로도 카메라 이동:
- `G` : 골인쪽
- `T` : 상단


---

## 7. UI(HTML) 구성 의도

좌측 패널은 “게임 조작 + 기록”
- 이름 입력
- 지목 등수
- Start/Reset
- 상태/대기열
- finish 로그(Recording)

우측 스테이지는 “레이스 시청”
- 메인 화면(game)
- 꼴찌가 안 보일 때만 등장하는 mini(Last)

즉,  
**조작(패널)과 관전(스테이지)을 분리**해서
사용자가 레이스를 보면서도 결과 기록을 동시에 확인할 수 있게 구성했습니다.
